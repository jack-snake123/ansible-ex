#!/bin/ksh
set -x

######################################<+>#######################################
#  File              : yilmlogs.sh
#  Project           : セキュリティログ監理支援システム
#  Description       : セキュリティログ保管処理
#  Language          : ksh
#  Date              : 2003.10.11
#  Author            : Akihiro Wakutsu
#  Update            : 2020.07.15
#                      テープストレージ利用案件にて更新
#                      2022.03.31
#                      「収集構成定義」「ログ保管」DBテーブル新設に伴う変更
######################################<+>#######################################

# テスト用 パラメータセット
BreakPoint()
{
 echo "ブレークポイント。"
 read bpt
}

#-----------------------------------------------------------------------------
# デバッグ用関数
#-----------------------------------------------------------------------------
echo_proc ()
{
	#引数を全て標準出力に出力する
	echo "$*" >> /tmp/yilmlogs_log.txt
	return 0
}

#-----------------------------------------------------------------------------
# 定数定義
#-----------------------------------------------------------------------------
# <<<<< 2022.03.31 Add Start >>>>>
	#スクリプト名
	MYSELF_SCRIPT_NAME="yilmlogs"				#自スクリプト名
# <<<<< 2022.03.31 Add End >>>>>

	#セキュリティログ収集処理-処理結果
	NORMAL_FLG=0							#正常
	ERROR_FLG=1								#異常

	#現在処理日・処理時間
	CNS_YMD=`date +"%Y%m%d"`				#日付
	CNS_HMS=`date +"%H%M%S"`				#時間

	#その他定数
	CHECK_0=0								#数字チェック用定数(0チェック)
	CHECK_1=1								#数字チェック用定数(1チェック)

	#保管セキュリティログ使用率
	CAP_LMT=95								#保管セキュリティログ使用率上限(%)

	#ログ種別用ディレクトリ名称
	LOG_SBT_N_DIR="ninshou"			#認証ログ
	LOG_SBT_A_DIR="access"			#アクセスログ
	LOG_SBT_O_DIR="operation"		#オペレーションログ
	LOG_SBT_E_DIR="etc"			#その他ログ
        #
        # 2004.08.05 追加
        #
        LOG_SBT_C_DIR="acount"                  #アカウントログ
        LOG_SBT_T_DIR="trace"                   #トレースログ

	#ログ種別チェック
	LOG_SBT_N="N"				#認証ログ
	LOG_SBT_A="A"				#アクセスログ
	LOG_SBT_O="O"				#オペレーションログ
	LOG_SBT_E="E"				#その他ログ
        #
        # 2004.08.05 追加
        #
        LOG_SBT_C="C"                           #アカウントログ
        LOG_SBT_T="T"                           #トレースログ

#-----------------------------------------------------------------------------
# 保管定義ファイル項目定数
#-----------------------------------------------------------------------------
	#収集構成定義ファイル項目番号（配列番号）
	#--- HDF_SEC_SUB=5 を削除
	#--- 件名「ディスク逼迫対応改良」にて実施
	#--- add 2010.01.26
	HDF_KMK_KSU=6							#項目数
	HDF_DEF_DIR=0							#保管構成定義ファイル格納先
	HDF_RLY_DIR=1							#収集処理結果格納先（中継ＳＶＲ用）
	HDF_MGR_DIR=2							#収集処理結果格納先（監理ＳＶＲ用）
	HDF_DAT_DIR=3							#保管情報格納先
	HDF_SEC_MAN=4							#保管セキュリティログ（正）格納先
	HDF_SEC_SUB=5							#保管セキュリティログ（副）格納先

#-----------------------------------------------------------------------------
# 収集結果ファイル項目定数
#-----------------------------------------------------------------------------
	#収集結果ファイル項目番号（配列番号）
	CRS_KMK_KSU=8							#項目数
	CRS_SVR_NAM=0							#サーバ名
	CRS_LOG_SBT=1							#ログファイル種類
	CRS_COL_YMD=2							#ログファイル作成日
	CRS_OPN_YMD=3							#収集実施日
	CRS_OPN_HMS=4							#収集実施時刻
	CRS_TMP_DIR=5							#一時領域格納先
	CRS_LOG_NAM=6							#ログファイル名
	CRS_COL_RES=7							#収集結果

	#収集結果
	COL_RES_GET=1							#セキュリティログ有
	COL_RES_NON=0							#セキュリティログ無
	COL_RES_ERR=2							#セキュリティログ収集エラー

	#収集結果ファイルソート条件
	#サーバ名、ログファイル種類、ログファイル作成日、収集実施日、収集実施時刻の順
	CRS_SORT="1,5"

#-----------------------------------------------------------------------------
# 保管情報インデックスファイル項目定数
#-----------------------------------------------------------------------------
	#保管情報インデックスファイル項目番号（配列番号）
	HIX_KMK_KSU=3							#項目数
	HIX_SVR_NAM=0							#サーバ名
	HIX_LOG_SBT=1							#ログファイル種類
	HIX_LOG_NAM=2							#ログファイル名

	#保管情報インデックスファイルソート条件
	#サーバ名、ログファイル種類
	HIX_SORT="1,2"

#-----------------------------------------------------------------------------
# 保管情報ファイル項目定数
#-----------------------------------------------------------------------------
	#保管情報ファイル項目番号（配列番号）
	#--- HDT_DIR_SUB=4 を削除
	#--- 件名「ディスク逼迫対応改良」にて実施
	#--- add 2010.01.26
	HDT_KMK_KSU=7							#項目数
	HDT_SVR_NAM=0							#サーバ名
	HDT_LOG_SBT=1							#ログファイル種類
	HDT_COL_YMD=2							#ログファイル作成日
	HDT_DIR_MAN=3							#ログファイル格納先（正）
	HDT_DIR_SUB=4							#ログファイル格納先（副）
	HDT_LOG_NAM=5							#ログファイル名
	HDT_HKN_STS=6							#保管状態

	#保管状態
	HKN_STS_GET=1							#セキュリティログ有
	HKN_STS_NON=0							#セキュリティログ無
	HKN_STS_COL_ERR=2						#セキュリティログ収集エラー
	HKN_STS_HKN_ERR=3						#セキュリティログ保管エラー

	#保管情報インデックスファイルソート条件
	#サーバ名、ログファイル種類、ログファイル作成日
	HIX_SORT="1,3"

#-----------------------------------------------------------------------------
# alias定義
#-----------------------------------------------------------------------------
	#rmコマンド（確認無し）
	alias rm="rm -f"
	#mvコマンド（確認無し）
	alias mv="mv -f"
	#grepコマンド（エラーメッセージ無し）
	alias grep="grep -s"
	#mkdirコマンド（中間ディレクトリ作成）
	alias mkdir="mkdir -p"
	#ftpコマンド（自動ログイン無し）
	alias ftp="ftp -n"
	#rmdirコマンド（エラーメッセージ無し）
	alias rmdir="rmdir -s"

#-----------------------------------------------------------------------------
# 使用ディレクトリパス定義
#-----------------------------------------------------------------------------
	#セキュリティログ監理支援システム規定ディレクトリ
	DIR_HOME="/y/seclog/pyyiz001/yilm"		#ホームディレクトリ
	DIR_CONF="/y/seclog/pyyiz001/yilm/config"
											#コンフィグ情報格納ディレクトリ
	DIR_PGM="/y/seclog/pyyiz001/yilm/sbin"	#プログラム格納ディレクトリ
	DIR_SEC_LOG="/log"						#作業領域
	DIR_TEMP_AREA="temparea"				#セキュリティログ格納一時領域
	DIR_TRACELOG="/togounyo/syslog/trace/yi"
											#トレースログ格納先

	#各種作業領域
	DIR_WORK="${DIR_SEC_LOG}/yilmlogs"		#作業領域

#-----------------------------------------------------------------------------
# 使用ファイル定義
#-----------------------------------------------------------------------------
	#セキュリティログ監理支援システム規定ファイル
	FILE_TRACELOG="yilmlogs-${CNS_YMD}.txt" #トレースログ
	FILE_YICRES="yicres.txt"				#収集結果ファイル
	FILE_YISDEF="yisdef.txt"				#保管定義ファイル
# <<<<< 2022.03.31 Delete Start >>>>>
#	FILE_YISIDX="yisidx.txt"				#保管情報インデックスファイル
# <<<<< 2022.03.31 Delete End >>>>>

	#保管情報ファイル定数
	#保管情報ファイル名は"yisdata-サーバ名-ログ種別.txt"とする
	FILE_YISDAT_NAM="yisdata"				#保管情報ファイル名称
	FILE_YISDAT_EXT=".txt"					#保管情報ファイル拡張子

	#作業用ファイル名
	FILE_SORT_YICRES="sort-${FILE_YICRES}"	#ソート済み収集結果ファイル
	FILE_SORT_YISIDX="sort-${FILE_YISIDX}"	#ソート済み保管情報インデックスファイル
	FILE_TEMP_YISDAT="temp-YISDAT.txt"		#保管情報ファイル(一時ファイル)

#-----------------------------------------------------------------------------
# ファイル構成定義
#-----------------------------------------------------------------------------
	#各ファイル項目区切り文字
	#ユーザ設定ファイル
	#  保管定義ファイル
	KGI_USER=","

	#プログラム作成ファイル
	#  収集結果ファイル、保管情報インデックスファイル、保管情報ファイル
	KGI_PGM=","

	#トレースログ
	KGI_TRACE=" *"

# <<<<< 2022.03.31 Add Start >>>>>
#-----------------------------------------------------------------------------
# PostgreSQLテーブル定義
#-----------------------------------------------------------------------------
    DB_USER_ID="postgres"				#ユーザID

    DB_NAME_YICCODEF="yiccodef"			#収集構成定義DB
    DB_NAME_YISDATA="yisdata"			#ログ保管DB

    DB_TABLE_YICCODEF="yiccdtbl"		#収集構成定義テーブル
    DB_TABLE_YISDATA="yisdttbl"			#ログ保管テーブル

    TBLCD_ENTRY_SRV_CDC_MANAGE="1"		#定義登録先サーバコード：CDC監理サーバ
    TBLCD_ENTRY_SRV_CDC_RELAY="2"		#定義登録先サーバコード：CDC中継サーバ
    TBLCD_ENTRY_SRV_SDC_MANAGE="3"		#定義登録先サーバコード：SDC監理サーバ
    TBLCD_ENTRY_SRV_SDC_RELAY="4"		#定義登録先サーバコード：SDC中継サーバ
# <<<<< 2022.03.31 Add End >>>>>

#-----------------------------------------------------------------------------
# 標準出力制御
#-----------------------------------------------------------------------------
	DEV_NULL="/dev/null"					#標準出力無し

#-----------------------------------------------------------------------------
# トレースログ出力内容定義
#-----------------------------------------------------------------------------
	#キーワード
	TRACE_INFOM="infom"						#AP稼動情報
	TRACE_ERROR="error"						#エラー情報(他システム、環境要因)
	TRACE_FATAL="fatal"						#エラー情報(ジシステム要因)

	#戻り値
	TRACE_NORMAL_FLG=0						#正常
	TRACE_ERROR_FLG=1						#異常

	#内容
	#セキュリティログ保管処理開始時
	TRACE_001="セキュリティログ保管処理  開始"

	#セキュリティログ保管エラー
	TRACE_002="セキュリティログ保管エラー"

	#保管定義ファイルの内容が正しくない場合
	TRACE_003="保管定義ファイルエラー"

	#引数の指定内容に誤りが有る場合
	TRACE_004="引数指定内容エラー"

	#セキュリティログ保管処理実行終了時（正常終了時）
	TRACE_005="セキュリティログ保管処理  正常終了"

	#セキュリティログ保管処理実行終了時（異常終了時）
	TRACE_006="セキュリティログ保管処理  異常終了"
	
# <<<<< 2022.03.31 Add Start >>>>>
	#ログ保管テーブル登録失敗
	TRACE_007="ログ保管テーブル登録失敗"
# <<<<< 2022.03.31 Add End >>>>>

#-----------------------------------------------------------------------------
# 変数定義
#-----------------------------------------------------------------------------
	#グローバルな変数を定義する
	#グローバル変数は変数名+"_"とする

	#保管セキュリティログボリューム番号
	iVolCopy_=0								#ボリューム番号

	#保管情報格納領域
	iHknKsu_=0								#保管情報件数
	set -A cHknSvrNam_						#サーバ名
	set -A cHknLogSbt_						#ログファイル種類
	set -A cHknColYMD_						#ログファイル作成日
	set -A cHknOpnYMD_						#収集実施日
	set -A cHKnOpnHMS_						#収集実施時刻
	set -A cHknTmpDir_						#一時領域格納先
	set -A cHknLogNam_						#ログファイル名
	set -A cHknColRes_						#収集結果
	set -A cHknDirMan_						#格納先（正）
	set -A cHknDirSub_						#格納先（副）
	set -A cHknRes_							#保管結果

	#関数内の変数については関数内で定義する
	#命名規則は"関数名の頭文字_"+"変数名"とする

# トレースログ出力処理-Start

######################################<->#######################################
#  Name              : outTraceLog
#  Description       : トレースログ出力処理
#  Inputs            : $1         :キーワード
#                    : $2         :戻り値
#                    : $3         :内容
#  Outputs           : なし
#  Return            : NORMAL_FLG :正常終了
#  Procedures Called : なし
#  Date              : 2003.10.11
#  Update            :
######################################<->#######################################
outTraceLog ()
{

echo_proc " -- トレースログ出力処理 -- "

	otl_cYMD=`date +"%Y%m%d"`				#日付
	otl_cHMS=`date +"%H%M%S"`				#時刻

	#トレースログ出力先ディレクトリ存在チェック
	if [ ! -d "${DIR_TRACELOG}" ]
	  #トレースログ出力先ディレクトリが存在しない場合
	  then
		#トレースログ出力先ディレクトリ作成
		mkdir "${DIR_TRACELOG}" > "${DEV_NULL}" 2>&1
	fi

	#トレースログの出力
	#  出力内容
	#    "キーワード *日付 *時刻 *戻り値 *内容"
	#  区切り文字
	#    KGI_TRACE:" *"
	echo -e "$1${KGI_TRACE}\c"          >> "${DIR_TRACELOG}/${FILE_TRACELOG}"
	echo -e "${otl_cYMD}${KGI_TRACE}\c" >> "${DIR_TRACELOG}/${FILE_TRACELOG}"
	echo -e "${otl_cHMS}${KGI_TRACE}\c" >> "${DIR_TRACELOG}/${FILE_TRACELOG}"
	echo -e "$2${KGI_TRACE}\c"          >> "${DIR_TRACELOG}/${FILE_TRACELOG}"
	echo "$3"                        >> "${DIR_TRACELOG}/${FILE_TRACELOG}"

	#正常終了
	return ${NORMAL_FLG}

}

# トレースログ出力処理-End


# 保管定義情報取得処理-Start

######################################<->#######################################
#  Name              : getHknData
#  Description       : 保管定義情報取得処理
#  Inputs            : $1         :保管定義ファイル
#  Outputs           : 保管定義情報（配列形式）
#  Return            : NORMAL_FLG :正常終了
#                    : ERROR_FLG  :異常終了
#  Procedures Called : なし
#  Date              : 2003.10.11
#  Update            : 2010.01.26
#                      件名「ディスク逼迫対応改良」にて実施
######################################<->#######################################
getHknData ()
{

echo_proc " -- 保管定義情報取得処理 -- "

echo " -- 保管定義情報取得処理 開始 -- "

BreakPoint

	ghd_iCnt=0								#カウンタ
	ghd_iManKsu=0							#保管セキュリティログ（正）格納先件数
	ghd_iSubKsu=0							#保管セキュリティログ（副）格納先件数
	ghd_cDir=""								#ディレクトリ
	ghd_cHknRec=""							#保管定義ファイルレコード格納領域
	ghd_cTmpRec=""							#一時領域
	ghd_cTmpOne=""							#一時領域（一文字）
	set -A ghd_cHknDat						#保管定義情報格納領域（配列形式）

	#保管定義ファイルの存在チェック
	if [ ! -f "$1" ]
	  #保管定義ファイルが存在しない場合
	  then

echo " -- 保管定義ファイルが存在しない 異常終了 -- "

BreakPoint

		#異常終了
		return ${ERROR_FLG}
	fi

	#保管定義情報の取得
	#  1レコード:保管構成定義ファイル
	#  2レコード:収集処理結果格納先（ログ中継サーバ）
	#  3レコード:収集処理結果格納先（ログ監理サーバ）
	#  4レコード:保管情報格納先
	#  5レコード:保管セキュリティログ（正）格納先
	#  6レコード:保管セキュリティログ（副）格納先
	#保管定義ファイルのレコードが終了するまで読込む
	while read ghd_cHknRec > "${DEV_NULL}" 2>&1
	  do
		#前後空白削除
		ghd_cTmpRec=`echo "${ghd_cHknRec}"`

		#空白行は読み飛ばす
		if [ "" = "${ghd_cTmpRec}" ]
		  then
			continue
		fi

		#1文字取得
		ghd_cTmpOne=`echo "${ghd_cTmpRec}" | cut '-c1-1'`

		#一文字目が"#"の行は読み飛ばす
		if [ "#" = "${ghd_cTmpOne}" ]
		  then
			continue
		fi

		#レコード内容を収集定義情報格納領域に格納
		ghd_cHknDat[$ghd_iCnt]=${ghd_cTmpRec}

		#カウンタの加算
		ghd_iCnt=$((${ghd_iCnt} + 1))
	  done < "$1"

	#取得レコード数チェック
	if [ "${HDF_KMK_KSU}" -ne "${#ghd_cHknDat[*]}" ]
	  #取得レコード数（項目数）が正しくない場合
	  then

echo " -- 保管定義ファイル 取得レコード数チェックエラー 異常終了 -- "

BreakPoint

		#異常終了
		return ${ERROR_FLG}
	fi

	#使用しない項目についてはチェックは行わない（11/19）

	#保管構成定義ファイル格納先存在チェック
	#if [ ! -d "${ghd_cHknDat[$HDF_DEF_DIR]}" ]
	#  #保管構成定義ファイル格納先が存在しない場合
	#  then
	#	#異常終了
	#	return ${ERROR_FLG}
	#fi

	#収集処理結果格納先（ログ中継サーバ用）存在チェック
	#if [ ! -d "${ghd_cHknDat[$HDF_RLY_DIR]}" ]
	#  #収集処理結果格納先（ログ中継サーバ用）が存在しない場合
	#  then
	#	#異常終了
	#	return ${ERROR_FLG}
	#fi

	#収集処理結果格納先（ログ監理サーバ用）存在チェック
	#if [ ! -d "${ghd_cHknDat[$HDF_MGR_DIR]}" ]
	#  #収集処理結果格納先（ログ監理サーバ用）が存在しない場合
	#  then
	#	#異常終了
	#	return ${ERROR_FLG}
	#fi

	#保管情報格納先の存在チェック
	if [ ! -d "${ghd_cHknDat[$HDF_DAT_DIR]}" ]
	  #保管情報格納先が存在しない場合
	  then

echo " -- 保管情報格納先の存在チェックエラー 異常終了 -- "

BreakPoint

		#異常終了
		return ${ERROR_FLG}
	fi

	#保管セキュリティログ（正）格納先の存在チェック
	ghd_iCnt=1
	ghd_iManKsu=`echo "${ghd_cHknDat[$HDF_SEC_MAN]}" | \
                 awk -F"${KGI_USER}" '{print NF}'`
	while [ "${ghd_iCnt}" -le "${ghd_iManKsu}" ]
	  do
		ghd_cDir=`echo "${ghd_cHknDat[$HDF_SEC_MAN]}" | \
                  awk -F"${KGI_USER}" '{print $'${ghd_iCnt}'}'`
		ghd_cDir=`echo ${ghd_cDir}`
		if [ ! -d "${ghd_cDir}" ]
		  #保管セキュリティログ（正）が存在しない場合
		  then

echo " -- 保管セキュリティログ格納先の存在チェックエラー 異常終了 -- "
			#異常終了
			return ${ERROR_FLG}
		fi
		#カウンタ増加
		ghd_iCnt=$((${ghd_iCnt} + 1))
	  done

	#保管セキュリティログ（副）格納先の存在チェック
	ghd_iCnt=1
	ghd_iSubKsu=`echo "${ghd_cHknDat[$HDF_SEC_SUB]}" | \
                awk -F"${KGI_USER}" '{print NF}'`
	while [ "${ghd_iCnt}" -le "${ghd_iSubKsu}" ]
	  do
		ghd_cDir=`echo "${ghd_cHknDat[$HDF_SEC_SUB]}" | \
                 awk -F"${KGI_USER}" '{print $'${ghd_iCnt}'}'`
		ghd_cDir=`echo ${ghd_cDir}`
		if [ ! -d "${ghd_cDir}" ]
		  #保管セキュリティログ（副）が存在しない場合
		  then

echo " -- 保管セキュリティログ格納先（副）の存在チェックエラー 異常終了 -- "

BreakPoint

			#異常終了
			return ${ERROR_FLG}
		fi
		#カウンタ増加
		ghd_iCnt=$((${ghd_iCnt} + 1))
	 done

	#保管セキュリティログ（正）と保管セキュリティログ（副）の件数チェック
	if [ "${ghd_iManKsu}" -ne "${ghd_iSubKsu}" ]
	  #件数が異なる場合
	  then

echo " -- 保管セキュリティログ（正）と保管セキュリティログ（副）の件数チェックエラー 異常終了 -- "

BreakPoint

		#異常終了
		return ${ERROR_FLG}
	fi

	#保管定義情報の出力
	echo "${ghd_cHknDat[*]}"

echo " -- 保管定義情報取得処理 終了 -- "

BreakPoint

	#正常終了
	return ${NORMAL_FLG}

}

# 保管定義情報取得処理-End


# 引数取得処理-Start

######################################<->#######################################
#  Name              : getParam
#  Description       : 引数取得処理
#  Inputs            : $1         :保管対象情報格納先１
#                    : $2         :保管対象情報格納先２
#  Outputs           : 保管対象情報格納先（配列形式）
#  Return            : NORMAL_FLG :正常終了
#                    : ERROR_FLG  :異常終了
#  Procedures Called : なし
#  Date              : 2003.10.11
#  Update            :       
######################################<->#######################################
getParam ()
{

echo_proc " -- 引数取得処理 -- "

echo " -- 引数取得処理 開始 -- "

BreakPoint

	gp_cDir=""								#ディレクトリ格納領域
	set -A gp_cHknTgtDir					#保管対象情報格納先

	#保管対象情報格納先の件数チェック
	if [ "2" -ne "$#" ]
	  #２件以上指定されていた場合
	  then

echo " -- 保管対象情報格納先の存在チェックエラー 異常終了 -- "

BreakPoint

		#異常終了（チェックエラー）
		return ${ERROR_FLG}
	fi

	#保管対象情報格納先の取得
	set -A gp_cHknTgtDir $@

	#保管対象情報格納先の存在チェック
	for gp_cDir in ${gp_cHknTgtDir[*]}
	  do
		if [ ! -d "${gp_cDir}" ]
		  then

echo " -- 保管対象情報格納先の存在チェックエラー 異常終了 -- "

BreakPoint

			#異常終了（チェックエラー）
			return ${ERROR_FLG}
		fi
	  done

	#保管対象情報格納先の出力
	echo "${gp_cHknTgtDir[*]}"

echo " -- 引数取得処理 終了 -- "

BreakPoint

	#正常終了
	return ${NORMAL_FLG}

}

# 引数取得処理-End


# 保管処理-Start

######################################<->#######################################
#  Name              : transactionHknData
#  Description       : 保管処理
#  Inputs            : $1                   :保管対象情報格納先
#                    : $2                   :保管情報格納先
#                    : $3                   :保管セキュリティログ（正）格納先
#  Outputs           : なし
#  Return            : NORMAL_FLG           :正常終了
#                    : ERROR_FLG            :異常終了
#  Procedures Called : transactionHknSecLog :ログファイル保管処理
#  Date              : 2003.10.11
#  Update            : 2010.01.26
#                      件名「ディスク逼迫対応改良」にて実施
######################################<->#######################################
transactionHknData ()
{

echo_proc " -- 保管処理 -- "

echo " -- 保管処理 開始 -- "

BreakPoint

	thd_iPrcStatus=${NORMAL_FLG}			#処理結果(関数)
	thd_iRetStatus=${NORMAL_FLG}			#処理結果
	thd_cDir=""								#ディレクトリ名
	set -A thd_cColDir						#収集結果格納ディレクトリ名(配列形式)

	#保管対象情報格納先から収集結果格納ディレクトリ名を取得する
	#ディレクトリ名は処理を実施した日付(YYYYMMDD)+時間(HHMMSS)となる
	set -A thd_cColDir `ls -l "$1" 2> "${DEV_NULL}" | \
                        awk '/^d/{print $9}' | sort -k1`

	#取得件数を確認
	if [ "${CHECK_0}" -ge "${#thd_cColDir[*]}" ]
	  #取得結果が０件の場合
	  then

echo " -- 保管処理 取得件数０件 正常終了 -- "

BreakPoint

		#正常終了(保管対象情報無し)
		return ${NORMAL_FLG}
	fi

	#収集結果格納ディレクトリ単位にセキュリティログの保管を実施
	for thd_cDir in ${thd_cColDir[*]}
	  do
		#ログファイル保管処理
		transactionHknSecLog "$1/${thd_cDir}" "$2" "$3" "$4"

		#処理結果の判定
		thd_iPrcStatus=$?

		if [ "${NORMAL_FLG}" = "${thd_iPrcStatus}" ]
		  #処理結果が正常終了の場合
		  then

echo " -- ログファイル保管処理 正常終了 -- "

BreakPoint

			#収集結果格納ディレクトリの削除
			rm -r "$1/${thd_cDir}" > "${DEV_NULL}" 2>&1
		  #処理結果が正常終了以外の場合
		  else

echo " -- ログファイル保管処理 異常終了 -- "

BreakPoint

			#処理結果に異常を格納
			thd_iRetStatus=${ERROR_FLG}
		fi
	  done

echo " -- 保管処理 終了 -- "

	#処理結果の返却
	return ${thd_iRetStatus}

}


######################################<->#######################################
#  Name              : transactionHknSecLog
#  Description       : ログファイル保管処理
#  Inputs            : $1                   :収集処理結果格納先
#                    : $2                   :保管情報格納先
#                    : $3                   :保管セキュリティログ（正）格納先
#  Outputs           : なし
#  Return            : NORMAL_FLG           :正常終了
#                    : ERROR_FLG            :異常終了
#  Procedures Called : createHknData        :保管情報作成処理
#                    : getHknTgtVolume      :保管対象ボリューム名取得処理
#                    : getLogSbtDir         :ログ種別ディレクトリ取得処理
#                    : deleteDirectory      :ログファイル格納先ディレクトリ削除処理
#                    : createColResultData  :収集結果情報作成処理
#                    : createHknTgtData     :保管先情報作成処理
#  Date              : 2003.10.11
#  Update            : 2010.01.26
#                      件名「ディスク逼迫対応改良」にて実施
######################################<->#######################################
transactionHknSecLog ()
{

echo_proc " -- ログファイル保管処理 -- "

echo " -- ログファイル保管処理 -- "

BreakPoint

	thsl_iCnt=0								#カウンタ
	thsl_cDirMan=""							#格納先（正）
	thsl_cDirSub=""							#格納先（副）
	thsl_cLogNam=""							#ログファイル名
	thsl_cLogDir=""							#ログ種別ディレクトリ
	thsl_cDir=""							#ディレクトリ名編集領域
	thsl_iPrcStatus=${NORMAL_FLG}			#処理結果
	thsl_iRetStatus=${NORMAL_FLG}			#エラーフラグ
	set -A thsl_cLogNamArray				#ログファイル名配列
	set -A thsl_cVolNam						#保管先ボリューム名（配列形式）

	#保管情報作成処理
	#グローバル変数の保管情報格納領域に収集結果ファイルの内容を格納する
	createHknData "$1"

	#保管情報無しとして終了する（保管完了）
	if [ "${CHECK_0}" -ge "${iHknKsu_}" ]
	  then

echo " -- 保管情報無しとして終了 正常終了 -- "

BreakPoint

		#正常終了
		return ${NORMAL_FLG}
	fi

	#保管情報の件数分以下の処理を実施
	while [ "${thsl_iCnt}" -lt "${iHknKsu_}" ]
	  do
		#収集結果の判定
		if [ "${COL_RES_GET}" = "${cHknColRes_[$thsl_iCnt]}" ]
		  #収集結果がセキュリティログ有の場合
		  then
			#保管対象ボリューム名取得処理
			#保管可能な保管セキュリティログのボリューム名を取得する
			#  配列０番:保管セキュリティログ（正）のボリューム名
			#  配列１番:保管セキュリティログボリューム番号
			set -A thsl_cVolNam `getHknTgtVolume "$3" "$4" "${iVolCopy_}"`

			#処理結果の取得
			thsl_iPrcStatus=$?

			#保管セキュリティログボリューム番号格納
			iVolCopy_=${thsl_cVolNam[2]}

			#保管対象ボリューム名取得処理の処理結果の確認
			if [ "${thsl_cVolNam[0]}" = "\"\"" ]
			  #正常終了以外の場合
			  then

echo " -- 取集結果がセキュリティログの場合 保管対象ボリューム名取得処理が正常終了以外 -- "

BreakPoint

				#処理結果に異常を格納
				thsl_iRetStatus=${ERROR_FLG}
				#保管結果に保管エラーを格納する
				cHknRes_[$thsl_iCnt]=${HKN_STS_HKN_ERR}
				#カウンタの加算
				thsl_iCnt=$((${thsl_iCnt} + 1))
				#次の情報を処理
				continue
			fi

			#ログ種別ディレクトリ取得
			thsl_cLogDir=`getLogSbtDir "${cHknLogSbt_[$thsl_iCnt]}"`

			#ディレクトリ名編集
			thsl_cDir="${cHknColYMD_[$thsl_iCnt]}/${cHknSvrNam_[$thsl_iCnt]}/${thsl_cLogDir}"

			#保管セキュリティログ（正）の格納先ディレクトリの作成
			#  "/保管セキュリティログ（正）のボリューム名＋
			#	/収集対象日/サーバ(サーバ名)/ログ種別"
			thsl_cDirMan="${thsl_cVolNam[0]}/${thsl_cDir}"
			mkdir "${thsl_cDirMan}" > "${DEV_NULL}" 2>&1

			#保管セキュリティログ（副）の格納先ディレクトリの作成
			#  "/保管セキュリティログ（副）のボリューム名＋
			#	/収集対象日/サーバ(サーバ名)/ログ種別"
			thsl_cDirSub="${thsl_cVolNam[1]}/${thsl_cDir}"
			mkdir "${thsl_cDirSub}" > "${DEV_NULL}" 2>&1

			#ログファイルを全て保管セキュリティログに移動する
			copy_flag=""		# "ERROR"になった場合、保管失敗のためJP1イベント通知する用
			for thsl_cLogNam in  ${cHknLogNam_[$thsl_iCnt]}
			  do
				#セキュリティログを保管セキュリティログ（正）にコピーする
				cp "$1/${DIR_TEMP_AREA}${cHknTmpDir_[$thsl_iCnt]}/${thsl_cLogNam}" \
                   "${thsl_cDirMan}/${thsl_cLogNam}" > "${DEV_NULL}" 2>&1
				# 2020.07.21 add
				#コピーに失敗した場合、副にコピーせずスキップする
				if [ "$?" != "0" ] ; then
					outTraceLog "${TRACE_FATAL}" "${TRACE_ERROR_FLG}" "status=保管失敗,type=正VOL,target=${thsl_cDirMan}/${thsl_cLogNam}"
					outTraceLog "${TRACE_FATAL}" "${TRACE_ERROR_FLG}" "status=保管失敗,type=副VOL,target=${thsl_cDirSub}/${thsl_cLogNam}"
					copy_flag="ERROR"
					continue
				else
					outTraceLog "${TRACE_INFOM}" "${TRACE_NORMAL_FLG}" "status=保管成功,type=正VOL,target=${thsl_cDirMan}/${thsl_cLogNam}"
				fi

				#セキュリティログを保管セキュリティログ（副）に移動する
				mv "$1/${DIR_TEMP_AREA}${cHknTmpDir_[$thsl_iCnt]}/${thsl_cLogNam}" \
                   "${thsl_cDirSub}/${thsl_cLogNam}" > "${DEV_NULL}" 2>&1
				# 2020.07.21 add
				if [ "$?" != "0" ] ; then
					outTraceLog "${TRACE_FATAL}" "${TRACE_ERROR_FLG}" "status=保管失敗,type=副VOL,target=${thsl_cDirSub}/${thsl_cLogNam}"
					copy_flag="ERROR"
				else
					outTraceLog "${TRACE_INFOM}" "${TRACE_NORMAL_FLG}" "status=保管成功,type=副VOL,target=${thsl_cDirSub}/${thsl_cLogNam}"
				fi
			  done
			if [ "${copy_flag}" = "ERROR" ] ; then
					/opt/jp1base/bin/jevsend -i 0 -e SEVERITY=Error -m "Failed to save the file. Please check the trace_log.(${DIR_TRACELOG}/${FILE_TRACELOG})"
			fi
				

			#ログファイル格納先ディレクトリの削除
			deleteDirectory "$1/${DIR_TEMP_AREA}${cHknTmpDir_[$thsl_iCnt]}"

			#保管情報の格納先（正）を設定
			cHknDirMan_[$thsl_iCnt]=${thsl_cDirMan}

			#保管情報の格納先（副）を設定
			cHknDirSub_[$thsl_iCnt]=${thsl_cDirSub}

			#保管結果にセキュリティログ有を格納する
			cHknRes_[$thsl_iCnt]=${HKN_STS_GET}

		  #収集結果がセキュリティログ有以外の場合
		  else
			#収集結果の判定
			if [ "${COL_RES_NON}" = "${cHknColRes_[$thsl_iCnt]}" ]
			  #収集結果がセキュリティログ無の場合
			  then
				#保管結果にセキュリティログ無を格納する
				cHknRes_[$thsl_iCnt]=${HKN_STS_NON}
			  #収集結果がセキュリティログ有でもセキュリティログ無でもない場合
			  #↑収集エラーの場合
			  else
				#保管結果にセキュリティログ収集エラーを格納する
				cHknRes_[$thsl_iCnt]=${HKN_STS_COL_ERR}
			fi
		fi
		#カウンタの加算
		thsl_iCnt=$((${thsl_iCnt} + 1))
	  done

	#収集結果情報作成処理
	createColResultData "$1"

	#保管先情報作成処理
	createHknTgtData "$2"

echo " -- ログファイル保管処理 終了 -- "

BreakPoint

	#処理結果の返却
	return ${thsl_iRetStatus}

}


######################################<->#######################################
#  Name              : createHknData
#  Description       : 保管情報作成処理
#  Inputs            : $1         :収集結果格納先
#  Outputs           : なし
#  Return            : NORMAL_FLG :正常終了
#  Procedures Called : なし
#  Date              : 2003.10.11
#  Update            : 2010.01.26
#                      件名「ディスク逼迫対応改良」にて実施
######################################<->#######################################
createHknData ()
{

echo_proc " -- 保管情報作成処理 -- "

echo " -- 保管情報作成処理 開始 -- "

BreakPoint

	cchd_iCnt=0								#カウンタ
	cchd_cRec=""							#収集結果ファイルレコード格納領域
	cchd_cSvrNam=""							#サーバ名
	cchd_cLogSbt=""							#ログファイル種類
	cchd_cTmpYMD=""							#ログファイル作成日
	cchd_cColOpn=""							#収集実施日+収集実施時刻
	cchd_cSvrNamB=""						#サーバ名（比較元）
	cchd_cLogSbtB=""						#ログファイル種類（比較元）
	cchd_cTmpYMDB=""						#ログファイル作成日（比較元）

	#保管情報格納領域の初期化
	iHknKsu_=0								#収集結果情報件数
	set -A cHknSvrNam_						#サーバ名
	set -A cHknLogSbt_						#ログファイル種類
	set -A cHknColYmd_						#ログファイル作成日
	set -A cHknOpnYMD_						#収集実施日
	set -A cHKnOpnHMS_						#収集実施時刻
	set -A cHknTmpDir_						#一時領域格納先
	set -A cHknLogNam_						#ログファイル名
	set -A cHknColRes_						#収集結果
	set -A cHknDirMan_						#格納先（正）
	set -A cHknDirSub_						#格納先（副）
	set -A cHknRes_							#保管結果

	#収集結果ファイルの存在チェック
	if [ ! -f "$1/${FILE_YICRES}" ]
	  #収集結果ファイルが存在しない場合
	  #（通常処理ではありえないが念のため実施）
	  then

echo " -- 収集結果ファイルが存在しない 処理終了 -- "

BreakPoint

		#現在の収集結果格納ディレクトリの処理は終了
		return ${NORMAL_FLG}
	fi

	#収集結果ファイルをサーバ名、ログファイル種類、ログファイル作成日、収集実施日、
    #収集実施時刻の順にソートする
	sort -t"${KGI_PGM}" -k"${CRS_SORT}" "$1/${FILE_YICRES}" > "${DIR_WORK}/${FILE_SORT_YICRES}"

	#ソート済みの収集結果ファイルのレコード件数分処理を実施
	#保管情報には、サーバ名、ログファイル種類、ログファイル作成日単位に格納する。
	#※サーバ名、ログファイル種類、ログファイル作成日が同一のレコードが存在した場合は
	#  最新の収集実施日、収集実施時刻(ソート済みのため、サーバ名、ログファイル種類、
	#  ログファイル作成日が一致した場合は最新のレコードとなる)のレコード内容を格納する。
	while read cchd_cRes > "${DEV_NULL}" 2>&1
	  do
		#サーバ名取得
		cchd_cSvrNam=`echo "${cchd_cRes}" | awk -F"${KGI_PGM}" \
                      '{print $'$((${CRS_SVR_NAM} + 1))'}'`
		#ログファイル種類取得
		cchd_cLogSbt=`echo "${cchd_cRes}" | awk -F"${KGI_PGM}" \
                      '{print $'$((${CRS_LOG_SBT} + 1))'}'`
		#ログファイル作成日取得
		cchd_cColYMD=`echo "${cchd_cRes}" | awk -F"${KGI_PGM}" \
                      '{print $'$((${CRS_COL_YMD} + 1))'}'`

		#サーバ名、ログファイル種類、ログファイル作成日比較
		if [ "${cchd_cSvrNam}" = "${cchd_cSvrNamB}" -a \
             "${cchd_cLogSbt}" = "${cchd_cLogSbtB}" -a \
             "${cchd_cColYMD}" = "${cchd_cColYMDB}" ]
		  #全て一致する場合（同一ログファイルの情報の場合）
		  then
			#保管情報に現在のレコードの情報を格納する
			cHknColRes_[$(($cchd_iCnt - 1))]=`echo "${cchd_cRes}" | \
                awk -F"${KGI_PGM}"  '{print $'$((${CRS_COL_RES} + 1))'}'`
			cHknTmpDir_[$(($cchd_iCnt - 1))]=`echo "${cchd_cRes}" | \
                awk -F"${KGI_PGM}" '{print $'$((${CRS_TMP_DIR} + 1))'}'`
			cHknLogNam_[$(($cchd_iCnt - 1))]=`echo "${cchd_cRes}" | \
                awk -F"${KGI_PGM}" '{print $'$((${CRS_LOG_NAM} + 1))'}'`
			cHknOpnYMD_[$(($cchd_iCnt - 1))]=`echo "${cchd_cRes}" | \
                awk -F"${KGI_PGM}" '{print $'$((${CRS_OPN_YMD} + 1))'}'`
			cHknOpnHMS_[$(($cchd_iCnt - 1))]=`echo "${cchd_cRes}" | \
                awk -F"${KGI_PGM}" '{print $'$((${CRS_OPN_HMS} + 1))'}'`
		  #一致しない場合（別ログファイルの情報の場合）
		  else
			#保管情報に現在のレコードの情報を格納する
			cHknSvrNam_[$cchd_iCnt]=${cchd_cSvrNam}
			cHknLogSbt_[$cchd_iCnt]=${cchd_cLogSbt}
			cHknColYMD_[$cchd_iCnt]=${cchd_cColYMD}

			#保管情報に現在のレコードの情報を格納する
			cHknColRes_[$cchd_iCnt]=`echo "${cchd_cRes}" | awk -F"${KGI_PGM}" \
	                                '{print $'$((${CRS_COL_RES} + 1))'}'`
			cHknTmpDir_[$cchd_iCnt]=`echo "${cchd_cRes}" | awk -F"${KGI_PGM}" \
                                    '{print $'$((${CRS_TMP_DIR} + 1))'}'`
			cHknLogNam_[$cchd_iCnt]=`echo "${cchd_cRes}" | awk -F"${KGI_PGM}" \
                                    '{print $'$((${CRS_LOG_NAM} + 1))'}'`
			cHknOpnYMD_[$cchd_iCnt]=`echo "${cchd_cRes}" | awk -F"${KGI_PGM}" \
                                    '{print $'$((${CRS_OPN_YMD} + 1))'}'`
			cHknOpnHMS_[$cchd_iCnt]=`echo "${cchd_cRes}" | awk -F"${KGI_PGM}" \
                                    '{print $'$((${CRS_OPN_HMS} + 1))'}'`

			#格納先（正）、保管結果を初期化
			cHknDirMan_[$cchd_iCnt]=""
			cHknDirSub_[$cchd_iCnt]=""
			cHknRes_[$cchd_iCnt]=""

			#カウンタを加算
			cchd_iCnt=$((${cchd_iCnt} + 1))

			#保管情報件数の加算
			iHknKsu_=$((${iHknKsu_} + 1))
		fi
	  done < "${DIR_WORK}/${FILE_SORT_YICRES}"

	if [ ! -f "${DIR_WORK}/${FILE_SORT_YICRES}" ]
	  then
		#ソート済みの収集結果ファイルを削除
		rm "${DIR_WORK}/${FILE_SORT_YICRES}" > "${DEV_NULL}" 2>&1
	fi

echo " -- 保管情報作成処理 終了 -- "

BreakPoint

	#正常終了
	return ${NORMAL_FLG}

}


######################################<->#######################################
#  Name              : getHknTgtVolume
#  Description       : 保管対象ボリューム名取得処理
#  Inputs            : $1                   :保管セキュリティログ（正）格納先
#                    : $2                   :保管セキュリティログ（副）格納先
#                    : $3                   :保管セキュリティログボリューム番号
#  Outputs           : 保管対象ボリューム名（配列形式）
#                    :  0:保管セキュリティログ（正）
#                    :  1:保管セキュリティログ（副）
#                    :  2:保管セキュリティログボリューム番号
#  Return            : NORMAL_FLG           :正常終了
#                    : ERROR_FLG            :異常終了
#  Procedures Called : なし
#  Date              : 2003.10.11
#  Update            : 2010.01.26
#                      件名「ディスク逼迫対応改良」にて実施
#                      2020.07.17
#                      テープストレージ対応で修正
######################################<->#######################################
getHknTgtVolume ()
{

echo_proc " -- 保管対象ボリューム名取得処理 -- "

echo " -- 保管対象ボリューム名取得処理 開始 -- "

BreakPoint

	ghtv_iCnt=$(($3 + 1))					#カウンタ
	ghtv_iVolNo=$3							#保管セキュリティログボリューム番号
	ghtv_iManCap=0							#保管セキュリティログ（正）使用率
	ghtv_iSubCap=0							#保管セキュリティログ（副）使用率
	ghtv_iVolKsu=0							#保管セキュリティログボリューム件数
	ghtv_cDirMan=""							#保管セキュリティログ（正）
	ghtv_cDirSub=""							#保管セキュリティログ（副）

	#保管セキュリティログボリューム件数取得
	ghtv_iVolKsu=`echo "$1" | awk -F"${KGI_USER}" '{print NF}'`

	#保管セキュリティログ（正）と保管セキュリティログ（副）の容量チェック
	while [ "${ghtv_iCnt}" -le "${ghtv_iVolKsu}" ]
	  do
		#保管セキュリティログ（正）のボリューム名取得
		ghtv_cDirMan=`echo "$1" | awk -F"${KGI_USER}" '{print $'${ghtv_iCnt}'}'`
		ghtv_cDirMan=`echo ${ghtv_cDirMan}`

		#保管セキュリティログ（副）のボリューム名取得
		ghtv_cDirSub=`echo "$2" | awk -F"${KGI_USER}" '{print $'${ghtv_iCnt}'}'`
		ghtv_cDirSub=`echo ${ghtv_cDirSub}`

		#保管セキュリティログ（正）の使用率取得
### 2016.03.22
### DEBUG_ENV
		ghtv_iManCap=`df -P -k "${ghtv_cDirMan}" | grep / | awk '{print $5}' | sed 's/%//'`
###		ghtv_iManCap=`df -P -k "${ghtv_cDirMan}" | grep /log | awk '{print $5}' | sed 's/%//'`

### 2016.03.22
### DEBUG_ENV
#ghtv_iManCap=80

		#保管セキュリティログ（副）の使用率取得
		ghtv_iSubCap=`df -P -k "${ghtv_cDirSub}" | grep / | awk '{print $5}' | sed 's/%//'`

### 2007.10.10 対応
### 旧ディスク(Newtech Disk)でのログ保管利用中止対応
### 対象パーティション：/log1,/log2,/log3,/log4,/log5,/log6
###                     /bk_log1,/bk_log2,/bk_log3,/bk_log4,/bk_log5,/bk_log6
### Start
		case ${ghtv_cDirMan} in
		/log[1-6])
			ghtv_iManCap="99"
			#ghtv_iSubCap="99"
			;;
		*)
			;;
		esac
### End
		#保管セキュリティログ（正）と保管セキュリティログ（副）の使用率判定
		if [ "" != "${ghtv_iManCap}" -a "" != "${ghtv_iSubCap}" ]
		  #使用率が正しく取得できた場合
		  then
			#使用率判定
			if [ "${CAP_LMT}" -ge "${ghtv_iManCap}" -a \
                 "${CAP_LMT}" -ge "${ghtv_iSubCap}"    ]
			  #使用率が上限値以下の場合
			  then
				#現在のボリューム名を出力する
                echo ""${ghtv_cDirMan}" "${ghtv_cDirSub}" "${ghtv_iVolNo}""

echo " -- 保管対象ボリューム名取得処理 終了 -- "

BreakPoint

				#正常終了
				return ${NORMAL_FLG}
			fi
		fi

		#カウンタの加算
		ghtv_iCnt=$((${ghtv_iCnt} + 1))

		#保管セキュリティログボリューム番号の加算
		ghtv_iVolNo=$((${ghtv_iVolNo} + 1))

	  done

	#ボリューム名を出力する
	echo "\"\""
	echo "\"\""
	echo "${ghtv_iVolNo}"

echo " -- 保管対象ボリューム名取得処理 使用率の上限超過で異常終了 -- "

BreakPoint

	#全てのボリュームが使用率の上限を超過している場合
	#異常終了
	return ${ERROR_FLG}

}


######################################<->#######################################
#  Name              : getLogSbtDir
#  Description       : ログ種別ディレクトリ取得処理
#  Inputs            : $1         :ログ種別（'N','A','O','E'）
#  Outputs           : ログ種別ディレクトリ
#  Return            : NORMAL_FLG :正常終了
#  Procedures Called : なし
#  Date              : 2003.10.11
#  Update            :       
######################################<->#######################################
getLogSbtDir ()
{

echo_proc " -- ログ種別ディレクトリ取得処理 -- "

echo " -- ログ種別ディレクトリ取得処理 開始 -- "

BreakPoint

	case "$1" in
	  #認証ログログ種別の場合
	  ${LOG_SBT_N})
		echo "${LOG_SBT_N_DIR}"
	  	;;
	  #アクセスログの場合
	  ${LOG_SBT_A})
		echo "${LOG_SBT_A_DIR}"
		;;
	  #オペレーションログの場合
	  ${LOG_SBT_O})
		echo "${LOG_SBT_O_DIR}"
		;;
	  #その他ログの場合
	  ${LOG_SBT_E})
		echo "${LOG_SBT_E_DIR}"
		;;
          #2004.08.05 追加
          #アカウントログの場合
          ${LOG_SBT_C})
                echo "${LOG_SBT_C_DIR}"
                ;;
          #2004.08.05 追加
          #トレースログの場合
          ${LOG_SBT_T})
                echo "${LOG_SBT_T_DIR}"
                ;;
	  #ログ種別が該当しない場合
	  *)
		#該当してしまった場合にはその他ログのディレクトリ名を出力する。
		echo "${LOG_SBT_E_DIR}"
		;;
	esac

echo " -- ログ種別ディレクトリ取得処理 終了 -- "

BreakPoint

	#正常終了
	return ${NORMAL_FLG}

}


######################################<->#######################################
#  Name              : createColResultData
#  Description       : 収集結果情報作成処理
#  Inputs            : $1               :収集処理結果格納先
#  Outputs           : なし
#  Return            : NORMAL_FLG       :正常終了
#  Procedures Called : outColResultData :収集結果ファイル出力処理
#  Date              : 2003.10.11
#  Update            : 2022.03.31
######################################<->#######################################
createColResultData ()
{

echo_proc " -- 収集結果情報作成処理 -- "

echo " -- 収集結果情報作成処理 開始 -- "

BreakPoint

	ccrd_iCnt=0								#カウンタ

	#作業領域に収集結果ファイルが存在する場合は削除する
	if [ -f "${DIR_WORK}/${FILE_YICRES}" ]
	  then
		#作業領域に収集結果ファイルの移動
		rm "${DIR_WORK}/${FILE_YICRES}" > "${DEV_NULL}" 2>&1
	fi

	#保管情報の保管結果がセキュリティログ有、セキュリティログ無、収集エラー以外
	#であるものを収集結果ファイルに格納する＝保管エラーの情報
	#正常に保管が実施できなかった情報を収集結果ファイルに残すことにより次回の
	#保管処理で再度保管を実施することが可能となる。

	#保管情報の件数分処理を実施
	while [ "${ccrd_iCnt}" -lt "${iHknKsu_}" ]
	  do
		#保管結果のチェック
		if [ "${HKN_STS_GET}"     != "${cHknRes_[$ccrd_iCnt]}" -a \
             "${HKN_STS_NON}"     != "${cHknRes_[$ccrd_iCnt]}" -a \
             "${HKN_STS_COL_ERR}" != "${cHknRes_[$ccrd_iCnt]}"     ]
		  #セキュリティログ有、セキュリティログ無、セキュリティログ収集エラー
		  #以外の場合=セキュリティログ保管エラーの場合
		  then
			#作業領域の収集結果ファイルに保管情報の内容を出力する
			outColResultData "${DIR_WORK}/${FILE_YICRES}" \
                             "${cHknSvrNam_[$ccrd_iCnt]}" \
                             "${cHknLogSbt_[$ccrd_iCnt]}" \
                             "${cHknColYMD_[$ccrd_iCnt]}" \
                             "${cHknOpnYMD_[$ccrd_iCnt]}" \
                             "${cHknOpnHMS_[$ccrd_iCnt]}" \
                             "${cHknTmpDir_[$ccrd_iCnt]}" \
                             "${cHknLogNam_[$ccrd_iCnt]}" \
                             "${cHknColRes_[$ccrd_iCnt]}"
		fi

		#カウンタの加算
		ccrd_iCnt=$((${ccrd_iCnt} + 1))

	  done

	#収集結果ファイルの削除
	if [ -f "$1/${FILE_YICRES}" ]
	  then
		#収集結果ファイルを削除する
		rm "$1/${FILE_YICRES}" > "${DEV_NULL}" 2>&1
	fi

	#作業領域の収集結果ファイルを収集結果格納先に移動する
	if [ -f "${DIR_WORK}/${FILE_YICRES}" ]
	  then
		#作業領域に収集結果ファイルの移動
		mv "${DIR_WORK}/${FILE_YICRES}" "$1/${FILE_YICRES}" \
           > "${DEV_NULL}" 2>&1
	fi

echo " -- 収集結果情報作成処理 終了 -- "

BreakPoint

	#正常終了
	return ${NORMAL_FLG}

}


######################################<->#######################################
#  Name              : outColResultData
#  Description       : 収集結果ファイル出力処理
#  Inputs            : $1               :収集結果ファイル
#                    : $2               :サーバ
#                    : $3               :ログファイル種類
#                    : $4               :ログファイル作成日
#                    : $5               :収集実施日
#                    : $6               :収集実施時刻
#                    : $7               :一時領域格納先
#                    : $8               :ログファイル名
#                    : $9               :収集結果
#  Outputs           : なし
#  Return            : NORMAL_FLG       :正常終了
#  Procedures Called : なし
#  Date              : 2003.10.11
#  Update            :       
######################################<->#######################################
outColResultData ()
{

echo_proc " -- 収集結果ファイル出力処理 -- "

echo " -- 収集結果ファイル出力処理 開始 -- "

BreakPoint

	#収集結果ファイルの出力
	#  出力内容
	#    "サーバ名,ログファイル種類,ログファイル作成日、収集実施日、収集実施時刻,
	#     一時領域格納先,ログファイル名,収集結果"
	#  区切り文字
	#    KGI_PGM:","
	echo -e "$2${KGI_PGM}\c" >> "$1"
	echo -e "$3${KGI_PGM}\c" >> "$1"
	echo -e "$4${KGI_PGM}\c" >> "$1"
	echo -e "$5${KGI_PGM}\c" >> "$1"
	echo -e "$6${KGI_PGM}\c" >> "$1"
	echo -e "$7${KGI_PGM}\c" >> "$1"
	echo -e "$8${KGI_PGM}\c" >> "$1"
	echo "$9"             >> "$1"

echo " -- 収集結果ファイル出力処理 終了 -- "

BreakPoint

	#正常終了
	return ${NORMAL_FLG}

}


# <<<<< 2022.03.31 Add Start >>>>>
######################################<->#######################################
#  Name              : fncLogSaveTableRegist
#  Description       : ログ保管テーブル登録処理
#  Inputs            : $1               :サーバ名
#                    : $2               :ログファイル種類
#                    : $3               :ログファイル作成日
#                    : $4               :格納先（正）
#                    : $5               :格納先（副）
#                    : $6               :ログファイル名
#                    : $7               :収集結果
#  Outputs           : なし
#  Return            : NORMAL_FLG       :正常終了
#                    : ERROR_FLG        :異常終了
#  Procedures Called : なし
#  Date              : 2022.03.31
#  Update            : 
######################################<->#######################################
fncLogSaveTableRegist ()
{

echo_proc " -- ログ保管テーブル登録処理 -- "

echo " -- ログ保管テーブル登録処理 開始 -- "

BreakPoint

    flstr_iRetSts=${NORMAL_FLG}				#処理結果
	flstr_sRet=""							#文字列バッファ
	flstr_sReplaceLogName=""				#日付数字文字列をYYYYMMDDに変換したファイル名文字列
	flstr_sSql=""							#SQL作成用文字列バッファ
	flstr_sFilePath=""						#文字列バッファ
    flstr_sCollectTimeZoneCd=""				#ログファイル作成時間帯コード
    flstr_sSaveYear=""						#保管年数
    flstr_sInstLocateCd=""					#設置箇所コード
    flstr_sRegistServerCd=""				#定義登録先サーバコード
    flstr_nDateAddNum=0						#日付加算日数
    flstr_nLogFileSize=0					#ログファイルサイズ

#echo "サーバ名：$1"
#echo "ログファイル種類：$2"
#echo "ログファイル作成日：$3"
#echo "格納先（正）：$4"
#echo "格納先（副）：$5"
#echo "ログファイル名：$6"
#echo "収集結果：$7"
	
	#ログファイル名の数字日付文字列部分を「YYYYMMDD」に置き換えた文字列へ変換する
	flstr_sReplaceLogName=`fncDateNumstrReplace $6`
#echo "日付置換ログファイル名：${flstr_sReplaceLogName}"
	
	#収集構成定義テーブルからデータ取得
   	flstr_sSql="SELECT"
    flstr_sSql="$flstr_sSql  col_time_cd"
    flstr_sSql="$flstr_sSql ,sav_year"
    flstr_sSql="$flstr_sSql ,srv_place"
    flstr_sSql="$flstr_sSql ,entry_srv"
    flstr_sSql="$flstr_sSql from ${DB_TABLE_YICCODEF}"
    flstr_sSql="$flstr_sSql where (entry_srv='${TBLCD_ENTRY_SRV_CDC_MANAGE}'"
    flstr_sSql="$flstr_sSql or entry_srv='${TBLCD_ENTRY_SRV_SDC_MANAGE}')"
	flstr_sSql="$flstr_sSql and hst_name='$1'"
	flstr_sSql="$flstr_sSql and log_ctg_cd='$2'"
	flstr_sSql="$flstr_sSql and log_name='${flstr_sReplaceLogName}'"
    flstr_sSql="$flstr_sSql ;"
#echo "SQL(select): $flstr_sSql"
	
	psql -tAX \
	     --field-separator '|' \
	     -U ${DB_USER_ID} \
	     -d ${DB_NAME_YICCODEF} \
	     -c"${flstr_sSql}" \
         | IFS='|' \
         read flstr_sCollectTimeZoneCd \
			  flstr_sSaveYear \
              flstr_sInstLocateCd \
              flstr_sRegistServerCd
    
    #ログファイルフルパス作成：「格納先（正）」+「ログファイル名」
    flstr_sFilePath="$4/$6"
#echo "ログファイルフルパス： ${flstr_sFilePath}"
    
    #日付加算日数作成：「保管年数」× 365 ＋「保管年数」
#echo "保管年数： ${flstr_sSaveYear}"
	flstr_nDateAddNum=`expr ${flstr_sSaveYear} \* 365 + ${flstr_sSaveYear}`
#echo "日付加算日数： ${flstr_nDateAddNum}"
	
	#ログフィルのサイズ取得
	flstr_nLogFileSize=`ls -l ${flstr_sFilePath} | awk '{print $5}'`
#echo "ファイルサイズ： ${flstr_nLogFileSize}"
    
echo " -- ログ保管テーブルへ登録 -- "

BreakPoint

	#ログ保管テーブルへ登録
    flstr_sSql="insert into ${DB_TABLE_YISDATA} ("
    flstr_sSql="$flstr_sSql  hst_name"
    flstr_sSql="$flstr_sSql ,log_ctg_cd"
    flstr_sSql="$flstr_sSql ,col_time_cd"
    flstr_sSql="$flstr_sSql ,make_date"
    flstr_sSql="$flstr_sSql ,ctg_dir"
    flstr_sSql="$flstr_sSql ,ctg_dirsv"
    flstr_sSql="$flstr_sSql ,log_name"
    flstr_sSql="$flstr_sSql ,col_sts_cd"
    flstr_sSql="$flstr_sSql ,sav_day"
    flstr_sSql="$flstr_sSql ,log_sz"
    flstr_sSql="$flstr_sSql ,srv_place"
    flstr_sSql="$flstr_sSql ,entry_srv"
    flstr_sSql="$flstr_sSql ,entry_sh"
    flstr_sSql="$flstr_sSql ,time_stamp"
    flstr_sSql="$flstr_sSql ,seq_value"
    flstr_sSql="$flstr_sSql ) values ( "
    flstr_sSql="$flstr_sSql  '$1'"
    flstr_sSql="$flstr_sSql ,'$2'"
    flstr_sSql="$flstr_sSql ,${flstr_sCollectTimeZoneCd}"
    flstr_sSql="$flstr_sSql ,to_date('$3', 'YYYYMMDD')"
    flstr_sSql="$flstr_sSql ,'$4'"
    flstr_sSql="$flstr_sSql ,'$5'"
    flstr_sSql="$flstr_sSql ,'$6'"
    flstr_sSql="$flstr_sSql ,$7"
    flstr_sSql="$flstr_sSql ,to_date('$3', 'YYYYMMDD')+cast('${flstr_nDateAddNum} days' as INTERVAL)"
    flstr_sSql="$flstr_sSql ,${flstr_nLogFileSize}"
    flstr_sSql="$flstr_sSql ,'${flstr_sInstLocateCd}'"
    flstr_sSql="$flstr_sSql ,'${flstr_sRegistServerCd}'"
	flstr_sSql="$flstr_sSql ,'${MYSELF_SCRIPT_NAME}'"
	flstr_sSql="$flstr_sSql ,now()"
	flstr_sSql="$flstr_sSql ,nextval('seq_val')"
	flstr_sSql="$flstr_sSql )"
    flstr_sSql="$flstr_sSql ;"
	
	flstr_sRet=$(psql -tAX -U ${DB_USER_ID} -d ${DB_NAME_YISDATA} -c"${flstr_sSql}")
	if [[ "${flstr_sRet}" != *INSERT* ]]; then
        
        #echo "ログ保管テーブル登録失敗"
	
echo " -- ログ保管テーブル登録失敗 -- "

BreakPoint
	
	  	#ログ保管テーブル登録失敗
        #申請情報ファイルエラーのトレースログを出力する
        outTraceLog "${TRACE_FATAL}" "${TRACE_ERROR_FLG}" "${TRACE_007} 【SQL】${flstr_sSql}"
        flstr_iRetSts=${ERROR_FLG}
  	fi

echo " -- ログ保管テーブル登録成功 -- "

echo " -- ログ保管テーブル登録処理 終了 -- "

BreakPoint

	#正常終了
    return ${flstr_iRetSts}

}
# <<<<< 2022.03.31 Add End >>>>>

# <<<<< 2022.03.31 Add Start >>>>>
######################################<->#######################################
#  Name              : fncDateNumstrReplace
#  Description       : 日付数字文字置き換え処理
#                      [Ex] AB_20220331.gz → AB_YYYYMMDD.gz
#  Inputs            : $1	:ソース文字列
#  Outputs           : 置き換え処理済み文字列
#  Return            : なし
#  Procedures Called : なし
#  Date              : 2022/03/31
#  Update            : 
######################################<->#######################################
fncDateNumstrReplace ()
{
echo_proc " -- 日付数字文字置き換え処理 -- "

echo " -- 日付数字文字置き換え処理 開始 -- "

BreakPoint

    dnr_sRet=$1					#置き換え処理後文字列
    dnr_iLen=0                 	#文字長
    dnr_iCnt=0                 	#カウンタ
    dnr_bFlag=false				#フラグ
    dnr_iPtr=0                  #文字位置
    dnr_iVal=0                  #数値バッファ
    dnr_iNum=0                  #文字数
    dnr_sBuff=""				#文字列バッファ
    
    dnr_iLen=`expr length $1`
	
	if [ ${dnr_iLen} -gt 0 ]
	then
		for dnr_iCnt in `seq 1 ${dnr_iLen}`
		do
			dnr_sBuff=`echo $1 | cut -c ${dnr_iCnt}-${dnr_iCnt}`
			
			#数字文字列判定
			if [ ${dnr_sBuff} = "0" -o \
			     ${dnr_sBuff} = "1" -o \
			     ${dnr_sBuff} = "2" -o \
			     ${dnr_sBuff} = "3" -o \
			     ${dnr_sBuff} = "4" -o \
			     ${dnr_sBuff} = "5" -o \
			     ${dnr_sBuff} = "6" -o \
			     ${dnr_sBuff} = "7" -o \
			     ${dnr_sBuff} = "8" -o \
			     ${dnr_sBuff} = "9" ]
			then
				if [ ${dnr_bFlag} == false  ]
				then
					dnr_iPtr=${dnr_iCnt}
					dnr_iNum=1
					dnr_bFlag=true
				else
					dnr_iNum=$((${dnr_iNum} + 1))
				fi
			else
				if [ ${dnr_bFlag} == true -a ${dnr_iNum} -lt 8 ]
				then
					#数字文字の連続が8文字に満たなかった場合は日付数字文字となみなされないため、数字文字列判定をリセット
					dnr_iPtr=0
					dnr_iNum=0
					dnr_bFlag=false
				fi
			fi
		done
		
		#数字文字が8文字以上ある場合は最初の数字文字から8文字分を「YYYYMMDD」へ置換する
		if [ ${dnr_iPtr} -gt 0 -a ${dnr_iNum} -ge 8 ]
		then
			dnr_sRet=""
			if [ ${dnr_iPtr} -ge 2 ]
			then
				dnr_iVal=$((${dnr_iPtr} - 1))
				dnr_sRet=`echo $1 | cut -c 1-${dnr_iVal}`"YYYYMMDD"
			fi
			
			dnr_iVal=$((${dnr_iPtr} + 8))
			if [ ${dnr_iVal} -le ${dnr_iLen} ]
			then
				for dnr_iCnt in `seq ${dnr_iVal} ${dnr_iLen}`
				do
					dnr_sRet="${dnr_sRet}"`echo $1 | cut -c ${dnr_iCnt}-${dnr_iCnt}`
				done
			fi
		fi
	fi

echo " -- 日付数字文字置き換え処理 終了 -- "

BreakPoint
	
	echo ${dnr_sRet}

}
# <<<<< 2022.03.31 Add End >>>>>

######################################<->#######################################
#  Name              : createHknTgtData
#  Description       : 保管先情報作成処理
#  Inputs            : $1                   :保管情報格納先
#  Outputs           : なし
#  Return            : NORMAL_FLG           :正常終了
#  Procedures Called : outHknIdxFile        :保管情報インデックスファイル出力処理
#                    : outHknDataFile       :保管情報ファイル出力処理
#  Date              : 2003.10.11
#  Update            : 2022.03.31
######################################<->#######################################
createHknTgtData ()
{

echo_proc " -- 保管先情報作成処理 -- "

echo " -- 保管先情報作成処理 開始 -- "

BreakPoint

	chtd_iCnt=0								#カウンタ
	chtd_cSvr=""							#サーバ名
	chtd_cLogSbt=""							#ログ種別
	chtd_cHknDatNam=""						#保管情報ファイル名

	#保管情報の件数分処理を実施
	while [ "${chtd_iCnt}" -lt "${iHknKsu_}" ]
	  do
		#サーバ名、ログ種別が変化した場合
		if [ "${chtd_cSvr}"    != "${cHknSvrNam_[$chtd_iCnt]}" -o \
             "${chtd_cLogSbt}" != "${cHknLogSbt_[$chtd_iCnt]}"     ]
		  then

			#保管情報ファイル名の取得
			#  "yisdata-サーバ名-ログファイル種類.txt"
			chtd_cHknDatNam=${FILE_YISDAT_NAM}
			chtd_cHknDatNam="${chtd_cHknDatNam}-${cHknSvrNam_[$chtd_iCnt]}"
			chtd_cHknDatNam="${chtd_cHknDatNam}-${cHknLogSbt_[$chtd_iCnt]}"
			chtd_cHknDatNam="${chtd_cHknDatNam}${FILE_YISDAT_EXT}"

# <<<<< 2022.03.31 Delete Start >>>>>
#			#保管情報インデックスファイルの出力
#			outHknIdxFile "$1" "${cHknSvrNam_[$chtd_iCnt]}" \
#                         "${cHknLogSbt_[$chtd_iCnt]}" "${chtd_cHknDatNam}"
# <<<<< 2022.03.31 Delete Start >>>>>

			#サーバ名、ログ種別の取得
			chtd_cSvr=${cHknSvrNam_[$chtd_iCnt]}
			chtd_cLogSbt=${cHknLogSbt_[$chtd_iCnt]}
		fi

# <<<<< 2022.03.31 Replacee Start >>>>>
#		#保管情報ファイルの出力
#		outHknDataFile "$1" "${chtd_cHknDatNam}" "${cHknSvrNam_[$chtd_iCnt]}" \
#                       "${cHknLogSbt_[$chtd_iCnt]}" "${cHknColYMD_[$chtd_iCnt]}" \
#                       "${cHknDirMan_[$chtd_iCnt]}" \
#                       "${cHknLogNam_[$chtd_iCnt]}" "${cHknRes_[$chtd_iCnt]}" \
#                       "${cHknDirSub_[$chtd_iCnt]}"
#
         # ログ保管テーブル登録処理
         fncLogSaveTableRegist "${cHknSvrNam_[$chtd_iCnt]}" \
                               "${cHknLogSbt_[$chtd_iCnt]}" \
                               "${cHknColYMD_[$chtd_iCnt]}" \
					   		   "${cHknDirMan_[$chtd_iCnt]}" \
					   		   "${cHknDirSub_[$chtd_iCnt]}" \
                               "${cHknLogNam_[$chtd_iCnt]}" \
                               "${cHknRes_[$chtd_iCnt]}"
# <<<<< 2022.03.31 Replacee End >>>>

		#カウンタの増加
		chtd_iCnt=$((${chtd_iCnt} + 1))
	  done

echo " -- 保管先情報作成処理 終了 -- "

BreakPoint

	#正常終了
	return ${NORMAL_FLG}

}


######################################<->#######################################
#  Name              : outHknIdxFile
#  Description       : 保管情報インデックスファイル出力処理
#  Inputs            : $1         :保管情報格納先
#                    : $2         :サーバ名
#                    : $3         :ログファイル種類
#                    : $4         :保管情報ファイル名
#  Outputs           : なし
#  Return            : NORMAL_FLG :正常終了
#  Procedures Called : なし
#  Date              : 2003.10.11
#  Update            :       
######################################<->#######################################
outHknIdxFile ()
{

echo_proc " -- 保管情報インデックスファイル出力処理 -- "

echo " -- 保管情報インデックスファイル出力処理 開始 -- "

BreakPoint

	ohif_cRec=""							#保管情報インデックスレコード
	ohif_cFile=""							#保管情報ファイル名

	#保管情報インデックスファイルの存在チェック
	if [ -f "$1/${FILE_YISIDX}" ]
	  #保管情報インデックスファイルが存在する場合
	  then

echo " -- 保管情報インデックスファイル存在確認 -- "

BreakPoint

		#保管情報ファイルから該当するレコードを検索する
#		grep "^$2${KGI_PGM}$3${KGI_PGM}.*" "$1/${FILE_YISIDX}" |&
		grep "^$2${KGI_PGM}$3${KGI_PGM}.*" "$1/${FILE_YISIDX}" | while read \
							ohif_cRec > "${DEV_NULL}" 2>&1
#		while read -p ohif_cRec > "${DEV_NULL}" 2>&1
		  do
			#保管情報ファイル名の取得
			ohif_cFile=`echo "${ohif_cRec}" | awk -F"${KGI_PGM}" \
                      '{print $'$((${HIX_LOG_NAM} + 1))'}'`

			#保管情報ファイル名が引数の保管情報ファイル名と異なる場合は変更する
			#仕様上あり得ないためイレギュラー処理と位置づける
			if [ "${ohif_cFile}" != "$4" ]
			  then
				mv "$1/${ohif_cFile}" "$1/$4" > "${DEV_NULL}" 2>&1
			fi
		  done

		#保管情報インデックスファイルからサーバ名、ログファイル種類が一致しない
		#レコードのみを作業領域の一時ファイルに出力する
		grep -v "^$2${KGI_PGM}$3${KGI_PGM}.*" "$1/${FILE_YISIDX}" \
                > "${DIR_WORK}/${FILE_YISIDX}" 

		#保管情報インデックスファイルの削除
		#  削除するパスに注意
		rm "$1/${FILE_YISIDX}" > "${DEV_NULL}" 2>&1

		#一時ファイルを保管情報ファイルファイルにリネームする
		mv "${DIR_WORK}/${FILE_YISIDX}" "$1/${FILE_YISIDX}" > "${DEV_NULL}" 2>&1
	fi

	#保管情報インデックスファイルの出力
	#  出力内容
	#    "サーバ名,ログファイル種類,保管情報ファイル名"
	#  区切り文字
	#    KGI_PGM:","
	echo -e "$2${KGI_PGM}\c" >> "$1/${FILE_YISIDX}"
	echo -e "$3${KGI_PGM}\c" >> "$1/${FILE_YISIDX}"
	echo "$4"             >> "$1/${FILE_YISIDX}"


echo " -- 保管情報インデックスファイル出力処理 終了 -- "

BreakPoint

	#正常終了
	return ${NORMAL_FLG}

}


######################################<->#######################################
#  Name              : outHknDataFile
#  Description       : 保管情報ファイル出力処理
#  Inputs            : $1            :保管情報格納先
#                    : $2            :保管情報ファイル
#                    : $3            :サーバ名
#                    : $4            :ログファイル種類
#                    : $5            :ログファイル作成日
#                    : $6            :ログファイル格納先（正）
#                    : $7            :ログファイル名
#                    : $8            :保管結果
#                    : $9            :ログファイル格納先（副）
#  Outputs           : なし
#  Return            : NORMAL_FLG    :正常終了
#  Procedures Called : deleteLogFile :ログファイル削除処理
#  Date              : 2003.10.11
#  Update            : 2010.01.26
#                      件名「ディスク逼迫対応改良」にて実施
######################################<->#######################################
outHknDataFile ()
{

echo_proc " -- 保管情報ファイル出力処理 -- "

echo " -- 保管情報ファイル出力処理 開始 -- "

BreakPoint

	ohdc_cRec=""							#保管情報ファイルレコード
	ohdc_cSts=""							#保管状態
	ohdc_cDirMan=""							#ログファイル格納先（正）
	ohdc_cDirSub=""							#ログファイル格納先（副）
	ohdc_cLog=""							#ログファイル名
	ohdf_cYMD=`date +"%Y%m%d"`				#日付
	ohdf_cHMS=`date +"%H%M%S"`				#時刻

	#保管情報ファイルの存在チェック
	if [ -f "$1/$2" ]
	  #保管情報ファイルが存在する場合
	  then



		#保管情報ファイルから該当するレコードを検索する
		grep "^$3${KGI_PGM}$4${KGI_PGM}$5${KGI_PGM}.*${KGI_PGM}.*${KGI_PGM}.*" "$1/$2" | while read ohdc_cRec > "${DEV_NULL}" 2>&1
		  do
			#保管状態の取得
			ohdc_cSts=`echo "${ohdc_cRec}" | awk -F"${KGI_PGM}" \
                      '{print $'$((${HDT_HKN_STS} + 1))'}'`
			#ログファイル格納先、ログファイル名の取得
			ohdc_cDirMan=`echo "${ohdc_cRec}" | awk -F"${KGI_PGM}" \
                         '{print $'$((${HDT_DIR_MAN} + 1))'}'`
			ohdc_cDirSub=`echo "${ohdc_cRec}" | awk -F"${KGI_PGM}" \
                         '{print $'$((${HDT_DIR_SUB} + 1))'}'`
			ohdc_cLog=`echo "${ohdc_cRec}" | awk -F"${KGI_PGM}" \
                      '{print $'$((${HDT_LOG_NAM} + 1))'}'`

			#すでにセキュリティログが保管されている場合
			#仕様上はありえないケースの整合性をとるためのイレギュラー処理と位置づける
			if [ "$6" != "${ohdc_cDirMan}" -a "${HKN_STS_GET}" = "${ohdc_cSts}" ]
			  then
				#ログファイル削除
				deleteLogFile "${ohdc_cDirMan}" "${ohdc_cLog}" ""
			fi
			if [ "$6" = "${ohdc_cDirMan}" -a "${HKN_STS_GET}" = "${ohdc_cSts}" ]
			  then
				#ログファイル削除
				deleteLogFile "${ohdc_cDirMan}" "${ohdc_cLog}" "$7"
			fi
			if [ "$7" != "${ohdc_cDirSub}" -a "${HKN_STS_GET}" = "${ohdc_cSts}" ]
			  then
				#ログファイル削除
				deleteLogFile "${ohdc_cDirSub}" "${ohdc_cLog}" ""
			fi
			if [ "$7" = "${ohdc_cDirSub}" -a "${HKN_STS_GET}" = "${ohdc_cSts}" ]
			  then
				#ログファイル削除
				deleteLogFile "${ohdc_cDirSub}" "${ohdc_cLog}" "$8"
			fi
		  done

		#保管情報ファイルからサーバ名、ログファイル種類、ログファイル作成日
		#の全てが一致しないレコードのみを作業領域の一時ファイルに出力する
		grep -v "^$3${KGI_PGM}$4${KGI_PGM}$5${KGI_PGM}.*${KGI_PGM}.*${KGI_PGM}.*" \
                "$1/$2" > "${DIR_WORK}/${FILE_TEMP-YISDAT}"

		#保管情報ファイルの削除
		#  削除するパスに注意
		rm "$1/$2" > "${DEV_NULL}" 2>&1

		#一時ファイルを保管情報ファイルファイルにリネームする
		mv "${DIR_WORK}/${FILE_TEMP-YISDAT}" "$1/$2" > "${DEV_NULL}" 2>&1

	fi

	#保管情報ファイルの出力
	#  出力内容
	#    "サーバ名,ログファイル種類,ログファイル作成日,
	#     ログファイル格納先（正）,ログファイル名,保管状態"
	#  区切り文字
	#    KGI_PGM:","
	echo -e "$3${KGI_PGM}\c" >> "$1/$2"
	echo -e "$4${KGI_PGM}\c" >> "$1/$2"
	echo -e "$5${KGI_PGM}\c" >> "$1/$2"
	#保管結果のチェック
	if [ "${HKN_STS_GET}" = "$8" ]
	  #セキュリティログ有の場合
	  then
		#引数のログファイル格納先（正）、ログファイル名は
		#出力する
		echo -e "$6${KGI_PGM}\c" >> "$1/$2"
		#echo "$7${KGI_PGM}\c" >> "$1/$2"
		echo -e "$7${KGI_PGM}\c" >> "$1/$2"

	        # 格納ファイルサイズ取得 2016.03.22 改良
		SecLogFileSize=0
		Wk_F_Size=0

		for i in `echo $7`
		do
			# lsコマンドで格納対象ログフィルのサイズ取得
			Wk_F_Size=`ls -l ${6}/${i} | awk '{print $5}'`
			if [ "${Wk_F_Size}" != "" ] ; then
				SecLogFileSize=`expr ${SecLogFileSize} + ${Wk_F_Size}`
			fi
		done

	  #セキュリティログ有以外の場合
	  else
		#ログファイル格納先（正）、ログファイル名は""とする
		echo -e "${KGI_PGM}\c" >> "$1/$2"
		#echo "${KGI_PGM}\c" >> "$1/$2"
		echo -e "${KGI_PGM}\c" >> "$1/$2"


	        # 格納ファイルサイズ（ゼロ）設定 2016.03.22 改良
		SecLogFileSize=0

	fi

	#保管結果の出力
	# 0:セキュリティログ無
	# 1:セキュリティログ有
	# 2:セキュリティログ収集エラー
	# 3:セキュリティログ保管エラー
	echo -e "$8${KGI_PGM}\c" >> "$1/$2"

	# 格納ファイルサイズチェック
	if [ 1024 -gt ${SecLogFileSize} ]
	  then
	    # 格納ファイルサイズが1024Byte未満の場合	
	    if [ ${SecLogFileSize} -eq 0 ]
	      then
	 	SecLogFileSize=0
	      else
	 	SecLogFileSize=1
	    fi
	  else
	    # 格納ファイルサイズが1024Byte以上場合 ⇒ KByte 変換（Byte →　KByte）
	    KBSize=`expr ${SecLogFileSize} / 1024`
	    SecLogFileSize=${KBSize}
	fi

        # 格納ファイルサイズ（KByte）を最終項目に出力 2016.03.22 改良
	echo "${SecLogFileSize}" >> "$1/$2"

echo " -- 保管情報ファイル出力処理 終了 -- "

BreakPoint

	#正常終了
	return ${NORMAL_FLG}

}


######################################<->#######################################
#  Name              : deleteLogFile
#  Description       : ログファイル削除処理
#  Inputs            : $1              :ログファイル格納先
#                    : $2              :ログファイル名（削除対象）
#                    : $3              :ログファイル名（保管対象）
#  Outputs           : なし
#  Return            : NORMAL_FLG      :正常終了
#  Procedures Called : deleteDirectory :ログファイル格納先ディレクトリ削除処理
#  Date              : 2003.10.11
#  Update            :       
######################################<->#######################################
deleteLogFile ()
{

echo_proc " -- ログファイル削除処理 -- "

echo " -- ログファイル削除処理（ログ保管処理内） 開始 -- "

BreakPoint

	dlf_cLogNam=""							#ログファイル名
	set -A dlf_cLogNamArray1				#ログファイル名１（配列形式）
	set -A dlf_cLogNamArray2				#ログファイル名２（配列形式）

	#ログファイル名（削除対象）取得
	set -A dlf_cLogNamArray1 $2

	#ログファイル名（保管対象）取得
	set -A dlf_cLogNamArray2 $3

	#ログファイルを削除する
	for dlf_cLogNam in ${dlf_cLogNamArray1[*]}
	  do
		#ログファイル名（削除対象）がログファイル名（保管対象）に含まれている
		#かをチェックする
		echo "${dlf_cLogNamArray2[*]}" | grep -v "${dlf_cLogNam}" > "${DEV_NULL}" 2>&1

		if [ "${NORMAL_FLG}" != "$?" ]
		  #ログファイル名が含まれている場合
		  then
			#削除対象外
			continue
		fi

		#ログファイル格納先のログファイルの削除
		if [ -f "$1/${dlf_cLogNam}" ]
		  then
			rm "$1/${dlf_cLogNam}" > "${DEV_NULL}" 2>&1
		fi
	  done

	#ログファイル格納先ディレクトリ削除
	deleteDirectory "$1"

echo " -- ログファイル削除処理（ログ保管処理内） 終了 -- "

BreakPoint

	#正常終了
	return ${NORMAL_FLG}

}


######################################<->#######################################
#  Name              : deleteDirectory
#  Description       : ログファイル格納先ディレクトリ削除処理
#  Inputs            : $1         :ログファイル格納先
#  Outputs           : なし
#  Return            : NORMAL_FLG :正常終了
#  Procedures Called : なし
#  Date              : 2003.10.11
#  Update            :       
######################################<->#######################################
deleteDirectory ()
{

echo_proc " -- ログファイル格納先ディレクトリ削除処理 -- "

echo " -- ログファイル格納先ディレクトリ削除処理 開始 -- "

BreakPoint

	dd_iCnt=0								#カウンタ
	dd_iDirLen=0							#ログファイル格納先のディレクトリの深さ
	dd_cDir=""								#ディレクトリ名
	set -A dd_cDirDat						#ディレクトリ内容（配列形式）

	#ログファイル格納先の不要ディレクトリの削除
	#ログファイル作成日、サーバ名、ログファイル種類のディレクトリを削除する
	#3階層削除する
	dd_cDir=$1
	dd_iCnt=0
	while [ "${dd_iCnt}" -lt "3" ]
	  do
		#ディレクトリの存在チェック
		if [ -d "${dd_cDir}" ]
		  #ディレクトリが存在する場合
		  then
			set -A dd_cDirDat `ls "${dd_cDir}" 2> "${DEV_NULL}"`
			if [ "${CHECK_0}" -lt "${#dd_cDirDat[*]}" ]
			  #ディレクトリ内にファイルまたは、ディレクトリが存在する場合
			  then
				#ディレクトリの削除終了
				break
			fi

			#現在のディレクトリの削除
			rmdir "${dd_cDir}" > "${DEV_NULL}" 2>&1
		fi

		#ディレクトリの最下層を省く
		dd_cDir=${dd_cDir%/*}

		#カウントを1加算
		dd_iCnt=$((${dd_iCnt} + 1))
	  done

echo " -- ログファイル格納先ディレクトリ削除処理 終了 -- "

BreakPoint

	#正常終了
	return ${NORMAL_FLG}

}

# 保管処理-End


# セキュリティログ保管処理-Start

######################################<->#######################################
#  Name              : yilmlogs
#  Description       : セキュリティログ保管制御処理(メイン処理)
#  Inputs            : $1                 :保管対象情報格納先１
#                    : $2                 :保管対象情報格納先２
#  Outputs           : なし
#  Return            : NORMAL_FLG         :正常終了
#                    : ERROR_FLG          :異常終了
#  Procedures Called : outTraceLog        :トレースログ出力処理
#                    : getHknData         :保管定義情報取得処理
#                    : getParam           :引数取得処理
#                    : transactionHknData :保管処理
#  Date              : 2003.10.11
#  Update            : 2010.01.26
#                      件名「ディスク逼迫対応改良」にて実施
######################################<->#######################################

echo_proc "<-- セキュリティログ保管処理開始 `date +'%Y/%m/%d %H:%M:%S'` -->"

echo " -- セキュリティログ保管制御処理（メイン処理） 開始 -- "

BreakPoint

	iRetStatus=${NORMAL_FLG}				#処理結果
	iPrcStatus=${NORMAL_FLG}				#処理結果（関数）
	iErrFlg=${NORMAL_FLG}					#保管処理フラグ
	cDir=""									#ディレクトリ
	set -A cHknDat							#保管定義情報（配列形式）
	set -A cHknTgtDir						#保管対象情報格納先（配列形式）

	#--------------------------------------------------------------------------#
	# 作業領域の作成                                                           #
	#--------------------------------------------------------------------------#
	# 作業領域を作成する
	mkdir "${DIR_WORK}" > "${DEV_NULL}" 2>&1

	#--------------------------------------------------------------------------#
	# トレースログの出力                                                       #
	#--------------------------------------------------------------------------#
	# セキュリティログ保管処理の処理開始時のトレースログを出力する
	outTraceLog "${TRACE_INFOM}" "${TRACE_NORMAL_FLG}" "${TRACE_001}"

	#--------------------------------------------------------------------------#
	# 保管定義情報取得処理                                                     #
	#--------------------------------------------------------------------------#
	# 収集定義ファイルより収集定義情報を取得する
	set -A cHknDat `getHknData "${DIR_CONF}/${FILE_YISDEF}"`

	#保管定義情報取得処理の処理結果判定
	iPrcStatus=$?

echo_proc "    保管定義情報取得処理-処理結果                :${iPrcStatus}"

	if [ "${NORMAL_FLG}" != "${iPrcStatus}" ]
	  #処理結果が正常終了以外の場合
	  then

echo " -- 収集結果が正常終了以外の場合 -- "

BreakPoint

		#----------------------------------------------------------------------#
		# トレースログの出力                                                   #
		#----------------------------------------------------------------------#
		# 保管定義情報取得エラーのトレースログを出力する
		outTraceLog "${TRACE_FATAL}" "${TRACE_ERROR_FLG}" "${TRACE_003}"

		#処理結果に異常を格納
		iRetStatus=${ERROR_FLG}
	fi

echo_proc "    保管情報格納先                               :${cHknDat[$HDF_DAT_DIR]}"
echo_proc "    保管セキュリティログ（正）格納先             :${cHknDat[$HDF_SEC_MAN]}"
echo_proc "    保管セキュリティログ（副）格納先             :${cHknDat[$HDF_SEC_SUB]}"

	#引数の取得
	if [ "${NORMAL_FLG}" = "${iRetStatus}" ]
	  then
		#----------------------------------------------------------------------#
		# 引数取得処理                                                         #
		#----------------------------------------------------------------------#
		# 引数から保管対象情報格納先を取得する
		cHknTgtDir=`getParam "$@"`

		#引数取得処理の処理結果判定
		iPrcStatus=$?
		if [ "${NORMAL_FLG}" != "${iPrcStatus}" ]
		  #処理結果が正常終了以外の場合
		  then

echo "-- 引数取得が正常終了以外の場合 -- "

BreakPoint
			#------------------------------------------------------------------#
			# トレースログの出力                                               #
			#------------------------------------------------------------------#
			# 引数取得エラーのトレースログを出力する
			outTraceLog "${TRACE_FATAL}" "${TRACE_ERROR_FLG}" "${TRACE_004}"

			#処理結果に異常終了を格納
			iRetStatus=${ERROR_FLG}

		fi

echo_proc "    引数取得処理-処理結果                        :${iPrcStatus}"
echo_proc "    保管対象情報格納先                           :${cHknTgtDir}"

	fi

	#保管処理の実施
	if [ "${NORMAL_FLG}" = "${iRetStatus}" ]
	  then
		#保管セキュリティログのボリューム番号の初期化
		iVolCopy_=0

		#----------------------------------------------------------------------#
		# 保管処理                                                             #
		#----------------------------------------------------------------------#
		# 保管対象情報格納先内のセキュリティログを保管セキュリティログに格納する
		# 保管対象情報が存在しない場合は保管処理を実施せず終了となる
		for cDir in ${cHknTgtDir}
		  do
			#保管処理
			transactionHknData "${cDir}" "${cHknDat[$HDF_DAT_DIR]}" \
                               "${cHknDat[$HDF_SEC_MAN]}" \
                               "${cHknDat[$HDF_SEC_SUB]}"

			#保管処理の処理結果判定
			iPrcStatus=$?
			if [ ${NORMAL_FLG} != ${iPrcStatus} ]
			  #処理結果が正常終了以外の場合
			  then

echo " -- 保管処理が正常終了以外の場合 -- "

BreakPoint

				#保管処理フラグにエラーを格納
				iErrFlg=${ERROR_FLG}
			fi
		  done

		#保管処理フラグ確認
		if [ ${NORMAL_FLG} != ${iErrFlg} ]
		  #正常終了以外の場合
		  then

echo " -- 収集結果フラグが正常終了以外の場合 -- "

BreakPoint

			#トレースログ出力（セキュリティログ保管エラー）
			outTraceLog "${TRACE_FATAL}" "${TRACE_ERROR_FLG}" "${TRACE_002}"

			#処理結果に異常終了を格納
			iRetStatus=${ERROR_FLG}
		fi

echo_proc "    保管処理-処理結果                            :${iPrcStatus}"

	fi

	#--------------------------------------------------------------------------#
	# トレースログの出力                                                       #
	#--------------------------------------------------------------------------#
	# セキュリティログ保管処理の処理終了時のトレースログを出力する
	if [ "${NORMAL_FLG}" = "${iRetStatus}" ]
	  #処理結果が正常終了の場合
	  then

echo " -- セキュリティログ保管処理が正常終了の場合 -- "

BreakPoint

		#トレースログ出力（正常終了）
		outTraceLog "${TRACE_INFOM}" "${TRACE_NORMAL_FLG}" "${TRACE_005}"
	  #処理中にエラーが発生した場合
	  else

echo " -- セキュリティログ保管処理が正常終了以外の場合 -- "

BreakPoint

		#トレースログ出力（異常終了）
		outTraceLog "${TRACE_FATAL}" "${TRACE_ERROR_FLG}" "${TRACE_006}"
	fi

	#--------------------------------------------------------------------------#
	# 作業領域の削除                                                           #
	#--------------------------------------------------------------------------#
	# 作業領域の削除
	# ディレクトリ内のファイルも削除するため注意
	# 通常はディレクトリ内は空のため"rmdir"でも可能？
	rm -r "${DIR_WORK}" > "${DEV_NULL}" 2>&1

echo_proc "    セキュリティログ保管処理-処理結果            :${iRetStatus}"
echo_proc "<-- セキュリティログ保管処理終了 `date +'%Y/%m/%d %H:%M:%S'` -->"

### 20200821 add start ###
# <<<<< 2022.03.31 Delete Start >>>>>
#outTraceLog "${TRACE_INFOM}" "${TRACE_NORMAL_FLG}" "hkn_infバックアップ処理 開始"
#CYCLE=8 # 保存世代数（7世代残したい場合は+1の8と指定すること）
#BAKDATE=`date "+%Y%m%d_%H%M%S"`
#
#for i in "${cHknDat[$HDF_SEC_MAN]}" "${cHknDat[$HDF_SEC_SUB]}" ; do
#	outTraceLog "${TRACE_INFOM}" "${TRACE_NORMAL_FLG}" \
#		"バックアップファイル作成処理 処理開始 file=${i}/hkninf_backup/`hostname`-hkn-inf.tar.gz_${BAKDATE}"
#	cd /y/seclog/pyyiz001/
#	tar czf ${i}/hkninf_backup/`hostname`-hkn-inf.tar.gz_${BAKDATE} ./hkn_inf/yisdata-*.txt
#	RESULT_NUM=$?
#	if [ "${RESULT_NUM}" = "0" ] ; then
#		outTraceLog "${TRACE_INFOM}" "${TRACE_NORMAL_FLG}" \
#			"バックアップファイル作成処理 正常終了 file=${i}/hkninf_backup/`hostname`-hkn-inf.tar.gz_${BAKDATE}"
#	else
#		outTraceLog "${TRACE_ERROR}" "${TRACE_ERROR_FLG}" \
#			"バックアップファイル作成処理 異常終了 file=${i}/hkninf_backup/`hostname`-hkn-inf.tar.gz_${BAKDATE}. tar command return_code=${RESULT_NUM}."
#	fi
#	DELETEFILE=`ls -t  ${i}/hkninf_backup/$(hostname)-hkn-inf.tar.gz_* | tail -n+${CYCLE}`
#	if [ "${DELETEFILE}" = "" ] ; then
#		outTraceLog "${TRACE_INFOM}" "${TRACE_NORMAL_FLG}" "バックアップファイル世代管理 削除処理 file=none"
#	else
#		outTraceLog "${TRACE_INFOM}" "${TRACE_NORMAL_FLG}" "バックアップファイル世代管理 削除処理 file=${DELETEFILE}"
#		rm -f ${DELETEFILE}
#	fi
#done
#outTraceLog "${TRACE_INFOM}" "${TRACE_NORMAL_FLG}" "hkn_infバックアップ処理 終了"
# <<<<< 2022.03.31 Delete End >>>>>
### 20200821 add end ###

	#--------------------------------------------------------------------------#
	# 処理結果の返却                                                           #
	#--------------------------------------------------------------------------#
	# 呼び出し元に処理結果を返却し、処理を終了する
	#   ０      ：正常終了
	#   上記以外：異常終了
	exit ${iRetStatus}

# セキュリティログ保管処理-End

